C51 COMPILER V9.51   GLOBAL                                                                06/07/2018 15:04:25 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE GLOBAL
OBJECT MODULE PLACED IN ..\object\Global.obj
COMPILER INVOKED BY: E:\StudySoftWareInstall\keil4\C51\BIN\C51.EXE ..\user_files\Global.c BROWSE INCDIR(..\user_files) D
                    -EBUG OBJECTEXTEND PRINT(.\Global.lst) TABS(2) OBJECT(..\object\Global.obj)

line level    source

   1          #include"Stc12c5a.h"
   2          #include"Global.h"
   3          #include"intrins.h"
   4          
   5          INT16U wFaultRecord=0;
   6          xdata INT8U tbComUseBuf[60];
   7          xdata INT16U StartMotorTime = 0;
   8          bit NeedStarMotor = 0;
   9          
  10          
  11          INT32U xdata GlabalTimeCnt=0;
  12          INT32U xdata GlabalTimeTemp=0;
  13          
  14          //********************************  CRC  *****************************************
  15          code INT8U aucCRCHi[256] = {
  16              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  17              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  18              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  19              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  20              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  21              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  22              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  23              0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  24              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  25              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  26              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  27              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  28              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  29              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
  30              0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  31              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  32              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
  33              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
  34              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  35              0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
  36              0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
  37              0x00, 0xC1, 0x81, 0x40
  38          };
  39          
  40          code INT8U aucCRCLo[256] = {
  41              0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
  42              0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
  43              0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
  44              0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
  45              0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
  46              0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
  47              0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
  48              0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 
  49              0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
  50              0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
  51              0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
  52              0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
  53              0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 
  54              0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
C51 COMPILER V9.51   GLOBAL                                                                06/07/2018 15:04:25 PAGE 2   

  55              0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
  56              0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
  57              0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
  58              0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
  59              0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
  60              0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
  61              0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
  62              0x41, 0x81, 0x80, 0x40
  63          };
  64          
  65          INT16U usMBCRC16( INT8U * pucFrame, INT16U usLen ) 
  66          {
  67   1          INT16U ucCRCHi = 0xFF;
  68   1          INT8U ucCRCLo = 0xFF;
  69   1          INT16U  iIndex;
  70   1      
  71   1          while(usLen--)
  72   1          {
  73   2              iIndex = ucCRCLo ^ * pucFrame++;
  74   2              ucCRCLo = ucCRCHi ^ aucCRCHi[iIndex];
  75   2              ucCRCHi = aucCRCLo[iIndex];
  76   2          }
  77   1          return ( ucCRCHi << 8 | ucCRCLo );
  78   1      }
  79          
  80          //*************************************Task relevant************************************
  81          
  82          xdata TaskManage TaskManaTble[MAX_TASK_NUM];
  83          
  84          INT8U TaskStatCheck(INT8U TaskNum)
  85          {
  86   1        TaskManage *Temp;
  87   1        
  88   1          Temp = &TaskManaTble[TaskNum];
  89   1      
  90   1        return (Temp->TaskStatus);
  91   1      }
  92          
  93          void TaskPend(INT8U TaskNum)
  94          {
  95   1        TaskManage *Temp;
  96   1        
  97   1        Temp = &TaskManaTble[TaskNum];
  98   1        if(Temp->TaskStatus == TASK_READY)
  99   1        {
 100   2          Temp->TaskStatus = TASK_WAIT;
 101   2          Temp->TimeCnt = Temp->Period;
 102   2        }
 103   1      }
 104          
 105          void CreatTask(INT8U TaskNum,INT16U Periods)
 106          {
 107   1        TaskManage *Temp;
 108   1        Temp = &TaskManaTble[TaskNum];
 109   1        Temp->Period = Periods;
 110   1        Temp->TimeCnt = Periods;
 111   1        Temp->TaskStatus = TASK_WAIT;
 112   1      }
 113          
 114          //**************************************************************************************
 115          
 116          void InterruptControl(INT16U IntNum, bit Contr)
C51 COMPILER V9.51   GLOBAL                                                                06/07/2018 15:04:25 PAGE 3   

 117          {
 118   1        if(Contr == Enable)
 119   1        {
 120   2          IE |= (INT8U)IntNum;
 121   2          IE2 |= (IntNum>>9);  //right shift 9 bit,notice PCA not mention in PDF
 122   2        }
 123   1        else if(Contr == Disable)
 124   1        {
 125   2          IE &= ~(INT8U)IntNum;
 126   2          IE2 &= ~(IntNum>>9);
 127   2        }
 128   1      }
 129          
 130          //******************************  Set clear fault  **************************************
 131          void SetFault(INT16U Fault)
 132          {
 133   1        wFaultRecord |= Fault;
 134   1      }
 135          
 136          void ClrFault(INT16U Fault)
 137          {
 138   1        wFaultRecord &= (~Fault);
 139   1      }
 140          
 141          INT8U FaultChk(INT16U Fault)
 142          {
 143   1        if((wFaultRecord&Fault) == 0)
 144   1        {
 145   2          return NO_FAULT;
 146   2        }
 147   1      
 148   1        return 1;
 149   1      }
 150          
 151          INT8U ASCIIConvert(INT8U symbol,INT8U Type)
 152          {
 153   1        if(Type == CHAR_TO_NUM)
 154   1        {
 155   2          if((symbol>=0x30)&&(symbol<=0x39))
 156   2          {
 157   3            return (symbol-0x30);
 158   3          }
 159   2        }
 160   1        else if(Type == NUM_TO_CHAR)
 161   1        {
 162   2          if((symbol>=0)&&(symbol<=9))
 163   2          {
 164   3            return (symbol+0x30);
 165   3          }
 166   2        }
 167   1        
 168   1        return SPACE;
 169   1      }
 170          
 171          /****************************************************************************************************
 172          this delay fuction only use in DS18B20,the position must in this .c file,or,this fuction cant use normally
 173          *****************************************************************************************************/
 174          void Delay_1p8us(INT16U wDelayTime)  //call this fuction costs 3us,so,actual time is (wDelayTimex1.8+3)us
 175          {
 176   1        INT16U m;
 177   1        for(m=0;m<wDelayTime;m++);  //every loop cost 1.8us //Delay_1p8us(0) cost 3.08us
 178   1      }
C51 COMPILER V9.51   GLOBAL                                                                06/07/2018 15:04:25 PAGE 4   

 179          
 180          
 181          
 182          
 183          
 184          
 185          
 186          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    328    ----
   CONSTANT SIZE    =    512    ----
   XDATA SIZE       =     85    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
